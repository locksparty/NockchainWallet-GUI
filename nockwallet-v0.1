#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Nockchain Wallet Qt Interface v2.2.2
Interface graphique pour le wallet Nockchain
"""

import sys
import subprocess
import logging
import time
from pathlib import Path
from typing import Optional, Dict, Any, List, Tuple
import re

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QLineEdit, QTextEdit, QFileDialog,
    QMessageBox, QTabWidget, QGroupBox, QRadioButton, QCheckBox,
    QTableWidget, QTableWidgetItem, QHeaderView, QStatusBar, QComboBox,
    QSpinBox
)
from PyQt6.QtCore import Qt, QTimer
from PyQt6.QtGui import QFont, QPalette, QColor

from transaction_engine import TransactionEngine, TransactionResult

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Configuration globale
config = {
    'wallet_binary': 'nockchain-wallet',
    'wallet_path': '',
    'wallet_imported': True,
    'client_type': 'public',
    'public_server': 'https://nockchain-api.zorp.io',
    'private_port': '50051'
}


class OutputParser:
    """Parse et nettoie les sorties du wallet"""
    
    @staticmethod
    def extract_balance(output: str) -> Optional[float]:
        """Extrait le solde depuis la sortie"""
        try:
            match = re.search(r'Balance:\s*(\d+(?:\.\d+)?)\s*nicks', output)
            if match:
                return float(match.group(1))
            
            match = re.search(r'Total:\s*(\d+(?:\.\d+)?)\s*nicks', output)
            if match:
                return float(match.group(1))
            
            return None
        except Exception as e:
            logger.error(f"Erreur parse balance: {e}")
            return None
    
    @staticmethod
    def extract_address(output: str) -> Optional[str]:
        """Extrait l'adresse PKH depuis la sortie"""
        try:
            match = re.search(r'PKH \(base58\):\s*([a-zA-Z0-9]+)', output)
            if match:
                return match.group(1)
            
            match = re.search(r'Address:\s*([a-zA-Z0-9]+)', output)
            if match:
                return match.group(1)
            
            return None
        except Exception as e:
            logger.error(f"Erreur parse address: {e}")
            return None
    
    @staticmethod
    def extract_metadata(output: str) -> Dict[str, Any]:
        """Extrait les m√©tadonn√©es (hauteur, hash, etc.)"""
        metadata = {}
        try:
            height_match = re.search(r'Height:\s*(\d+)', output)
            if height_match:
                metadata['height'] = int(height_match.group(1))
            
            hash_match = re.search(r'Block hash:\s*([a-fA-F0-9]+)', output)
            if hash_match:
                metadata['block_hash'] = hash_match.group(1)
            
            version_match = re.search(r'Wallet version:\s*(\d+)', output)
            if version_match:
                metadata['wallet_version'] = int(version_match.group(1))
            
            notes_match = re.search(r'(\d+)\s*notes?', output)
            if notes_match:
                metadata['num_notes'] = int(notes_match.group(1))
            
            return metadata
        except Exception as e:
            logger.error(f"Erreur parse metadata: {e}")
            return metadata
    
    @staticmethod
    def parse_notes_list(output: str) -> List[Dict[str, str]]:
        """Parse la liste des notes depuis la sortie"""
        notes = []
        try:
            lines = output.split('\n')
            for line in lines:
                if 'nicks' in line and any(c.isdigit() for c in line):
                    parts = line.strip().split()
                    if len(parts) >= 3:
                        try:
                            amount = float(parts[-2])
                            name = ' '.join(parts[:-2])
                            notes.append({
                                'name': name.strip(),
                                'amount': amount,
                                'unit': 'nicks'
                            })
                        except ValueError:
                            continue
            
            return notes
        except Exception as e:
            logger.error(f"Erreur parse notes: {e}")
            return []
    
    @staticmethod
    def extract_success_message(output: str) -> Optional[str]:
        """Extrait le message de succ√®s final"""
        try:
            if "Command executed successfully" in output:
                return "‚úì Commande ex√©cut√©e avec succ√®s"
            if "successfully" in output.lower():
                return "‚úì Op√©ration r√©ussie"
            return None
        except:
            return None
    
    @staticmethod
    def extract_error(stderr: str) -> str:
        """Extrait l'erreur pertinente du stderr"""
        try:
            lines = stderr.split('\n')
            error_lines = []
            
            skip_patterns = [
                '[0m', '[32m', '[33m', 
                'trace', 'debug',
                'kernel::boot',
                'NockApp boot',
                'save interval'
            ]
            
            for line in lines:
                line = line.strip()
                if line and not any(pattern in line.lower() for pattern in skip_patterns):
                    if not line.startswith('--'):
                        error_lines.append(line)
            
            return '\n'.join(error_lines) if error_lines else stderr
        except:
            return stderr
    
    @staticmethod
    def clean_output(output: str) -> str:
        """Nettoie la sortie en gardant seulement l'essentiel"""
        try:
            lines = output.split('\n')
            clean_lines = []
            
            skip_patterns = [
                'kernel::boot',
                'NockApp boot cli',
                'build-hash',
                'nockapp: Nockapp save interval',
                'Command requires syncing',
                'Connected to public',
                'Received balance update'
            ]
            
            for line in lines:
                if line.strip() and not any(pattern in line for pattern in skip_patterns):
                    cleaned = re.sub(r'^I \(\d+:\d+:\d+\)\s*', '', line)
                    cleaned = re.sub(r'^\[.*?\]\s*', '', cleaned)
                    if cleaned.strip():
                        clean_lines.append(cleaned.strip())
            
            return '\n'.join(clean_lines)
        except:
            return output


class LogArea(QTextEdit):
    """Zone de log avec coloration"""
    
    def __init__(self):
        super().__init__()
        self.setReadOnly(True)
        self.setMaximumHeight(200)
        font = QFont("Courier", 10)
        self.setFont(font)
    
    def append_log(self, message: str, log_type: str = "info"):
        """Ajoute un message avec couleur selon le type"""
        colors = {
            "info": "#FFFFFF",
            "success": "#4CAF50",
            "warning": "#FF9800",
            "error": "#F44336",
            "command": "#2196F3"
        }
        color = colors.get(log_type, "#FFFFFF")
        self.append(f'<span style="color: {color};">{message}</span>')


class NockchainWalletGUI(QMainWindow):
    """Interface graphique principale du wallet Nockchain"""
    
    def __init__(self):
        super().__init__()
        self.parser = OutputParser()
        self.recipients = []
        
        self.setWindowTitle("Nockchain Wallet v2.2.2")
        self.setGeometry(100, 100, 1000, 700)
        
        self.init_ui()
        self._check_binary()
        
        # Initialiser le moteur de transaction
        self.tx_engine = None
        self._init_transaction_engine()
    
    def _init_transaction_engine(self):
        """Initialise le moteur de transaction"""
        try:
            self.tx_engine = TransactionEngine(
                wallet_binary=config['wallet_binary'],
                wallet_path=config['wallet_path'],
                client_type=config['client_type'],
                public_server=config['public_server'],
                tx_dir=str(Path.home() / ".nockchain" / "transactions")
            )
            logger.info("Moteur de transaction initialis√©")
        except Exception as e:
            logger.error(f"Erreur init moteur transaction: {e}")
    
    def init_ui(self):
        """Initialise l'interface utilisateur"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        
        main_layout.addWidget(self._create_wallet_section())
        
        self.tabs = QTabWidget()
        self.tabs.addTab(self._create_balance_tab(), "üí∞ Balance")
        self.tabs.addTab(self._create_send_tab(), "üì§ Envoyer")
        self.tabs.addTab(self._create_receive_tab(), "üì• Recevoir")
        self.tabs.addTab(self._create_notes_tab(), "üìù Notes")
        self.tabs.addTab(self._create_gas_tab(), "‚õΩ Gas")
        self.tabs.addTab(self._create_params_tab(), "‚öôÔ∏è Param√®tres")
        
        main_layout.addWidget(self.tabs)
        
        self.log_area = LogArea()
        main_layout.addWidget(self.log_area)
        
        self.statusBar().showMessage("Pr√™t")
        
        self.log_area.append_log("Interface Nockchain Wallet v2.2.2 initialis√©e", "success")
    
    def _create_wallet_section(self) -> QGroupBox:
        """Cr√©e la section de gestion du wallet"""
        group = QGroupBox("üíº Wallet")
        layout = QVBoxLayout()
        
        path_layout = QHBoxLayout()
        path_layout.addWidget(QLabel("Chemin:"))
        self.wallet_path_label = QLabel("Aucun wallet charg√©")
        self.wallet_path_label.setStyleSheet("color: #FF9800;")
        path_layout.addWidget(self.wallet_path_label)
        path_layout.addStretch()
        layout.addLayout(path_layout)
        
        buttons_layout = QHBoxLayout()
        
        btn_import = QPushButton("üì• Importer")
        btn_import.clicked.connect(self._import_wallet)
        buttons_layout.addWidget(btn_import)
        
        btn_export = QPushButton("üì§ Exporter")
        btn_export.clicked.connect(self._export_wallet)
        buttons_layout.addWidget(btn_export)
        
        layout.addLayout(buttons_layout)
        group.setLayout(layout)
        return group
    
    def _create_balance_tab(self) -> QWidget:
        """Cr√©e l'onglet Balance"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        balance_group = QGroupBox("Solde actuel")
        balance_layout = QVBoxLayout()
        
        self.balance_label = QLabel("-- nicks")
        self.balance_label.setStyleSheet("font-size: 32px; font-weight: bold; color: #4CAF50;")
        self.balance_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        balance_layout.addWidget(self.balance_label)
        
        btn_refresh = QPushButton("üîÑ Actualiser")
        btn_refresh.clicked.connect(self._refresh_balance)
        balance_layout.addWidget(btn_refresh)
        
        balance_group.setLayout(balance_layout)
        layout.addWidget(balance_group)
        
        layout.addStretch()
        widget.setLayout(layout)
        return widget
    
    def _create_send_tab(self) -> QWidget:
        """Cr√©e l'onglet Envoyer"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        recipient_group = QGroupBox("Destinataires")
        recipient_layout = QVBoxLayout()
        
        add_layout = QHBoxLayout()
        add_layout.addWidget(QLabel("Adresse:"))
        self.recipient_address = QLineEdit()
        self.recipient_address.setPlaceholderText("PKH en base58...")
        add_layout.addWidget(self.recipient_address)
        
        add_layout.addWidget(QLabel("Montant:"))
        self.recipient_amount = QSpinBox()
        self.recipient_amount.setMaximum(999999999)
        self.recipient_amount.setSuffix(" nicks")
        add_layout.addWidget(self.recipient_amount)
        
        btn_add_recipient = QPushButton("‚ûï Ajouter")
        btn_add_recipient.clicked.connect(self._add_recipient)
        add_layout.addWidget(btn_add_recipient)
        
        recipient_layout.addLayout(add_layout)
        
        self.recipients_list = QTextEdit()
        self.recipients_list.setMaximumHeight(100)
        self.recipients_list.setReadOnly(True)
        recipient_layout.addWidget(self.recipients_list)
        
        btn_clear = QPushButton("üóëÔ∏è Effacer tout")
        btn_clear.clicked.connect(self._clear_recipients)
        recipient_layout.addWidget(btn_clear)
        
        recipient_group.setLayout(recipient_layout)
        layout.addWidget(recipient_group)
        
        notes_group = QGroupBox("S√©lection des notes")
        notes_layout = QVBoxLayout()
        
        self.notes_table = QTableWidget()
        self.notes_table.setColumnCount(4)
        self.notes_table.setHorizontalHeaderLabels(["‚òë", "Nom", "Montant", "Unit√©"])
        self.notes_table.horizontalHeader().setStretchLastSection(True)
        notes_layout.addWidget(self.notes_table)
        
        btn_load_notes = QPushButton("üîÑ Charger les notes")
        btn_load_notes.clicked.connect(self._load_notes)
        notes_layout.addWidget(btn_load_notes)
        
        notes_group.setLayout(notes_layout)
        layout.addWidget(notes_group)
        
        fee_group = QGroupBox("Frais de transaction")
        fee_layout = QVBoxLayout()
        
        priority_layout = QHBoxLayout()
        priority_layout.addWidget(QLabel("Priorit√©:"))
        self.fee_priority = QComboBox()
        self.fee_priority.addItems(["Low", "Medium", "High", "Urgent"])
        self.fee_priority.setCurrentText("Medium")
        priority_layout.addWidget(self.fee_priority)
        priority_layout.addStretch()
        fee_layout.addLayout(priority_layout)
        
        custom_fee_layout = QHBoxLayout()
        self.custom_fee_check = QCheckBox("Frais personnalis√©s:")
        custom_fee_layout.addWidget(self.custom_fee_check)
        self.custom_fee_input = QSpinBox()
        self.custom_fee_input.setMaximum(999999)
        self.custom_fee_input.setValue(10)
        self.custom_fee_input.setSuffix(" nicks")
        self.custom_fee_input.setEnabled(False)
        self.custom_fee_check.toggled.connect(self.custom_fee_input.setEnabled)
        custom_fee_layout.addWidget(self.custom_fee_input)
        custom_fee_layout.addStretch()
        fee_layout.addLayout(custom_fee_layout)
        
        fee_group.setLayout(fee_layout)
        layout.addWidget(fee_group)
        
        btn_send = QPushButton("üì§ Cr√©er et envoyer la transaction")
        btn_send.setStyleSheet("QPushButton { background-color: #4CAF50; font-weight: bold; padding: 10px; }")
        btn_send.clicked.connect(self._create_transaction)
        layout.addWidget(btn_send)
        
        widget.setLayout(layout)
        return widget
    
    def _create_receive_tab(self) -> QWidget:
        """Cr√©e l'onglet Recevoir"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        address_group = QGroupBox("Votre adresse de r√©ception")
        address_layout = QVBoxLayout()
        
        self.receive_address = QLineEdit()
        self.receive_address.setReadOnly(True)
        self.receive_address.setPlaceholderText("Cliquez sur 'Afficher l'adresse' pour voir votre PKH")
        address_layout.addWidget(self.receive_address)
        
        btn_show = QPushButton("üëÅÔ∏è Afficher l'adresse")
        btn_show.clicked.connect(self._show_address)
        address_layout.addWidget(btn_show)
        
        btn_copy = QPushButton("üìã Copier")
        btn_copy.clicked.connect(self._copy_address)
        address_layout.addWidget(btn_copy)
        
        address_group.setLayout(address_layout)
        layout.addWidget(address_group)
        
        layout.addStretch()
        widget.setLayout(layout)
        return widget
    
    def _create_notes_tab(self) -> QWidget:
        """Cr√©e l'onglet Notes"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        notes_group = QGroupBox("Liste des notes disponibles")
        notes_layout = QVBoxLayout()
        
        btn_load = QPushButton("üîÑ Charger les notes")
        btn_load.clicked.connect(self._load_notes)
        notes_layout.addWidget(btn_load)
        
        self.notes_display = QTableWidget()
        self.notes_display.setColumnCount(3)
        self.notes_display.setHorizontalHeaderLabels(["Nom", "Montant", "Unit√©"])
        self.notes_display.horizontalHeader().setStretchLastSection(True)
        notes_layout.addWidget(self.notes_display)
        
        notes_group.setLayout(notes_layout)
        layout.addWidget(notes_group)
        
        widget.setLayout(layout)
        return widget
    
    def _create_gas_tab(self) -> QWidget:
        """Cr√©e l'onglet Gas"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        gas_group = QGroupBox("‚õΩ Gestion du Gas")
        gas_layout = QVBoxLayout()
        
        gas_layout.addWidget(QLabel("Fonctionnalit√©s Gas √† venir..."))
        
        gas_group.setLayout(gas_layout)
        layout.addWidget(gas_group)
        
        layout.addStretch()
        widget.setLayout(layout)
        return widget
    
    def _create_params_tab(self) -> QWidget:
        """Cr√©e l'onglet Param√®tres"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        binary_group = QGroupBox("Binaire Wallet")
        binary_layout = QHBoxLayout()
        binary_layout.addWidget(QLabel("Chemin:"))
        self.binary_path_input = QLineEdit(config['wallet_binary'])
        binary_layout.addWidget(self.binary_path_input)
        btn_browse = QPushButton("üìÅ Parcourir")
        btn_browse.clicked.connect(self._browse_binary)
        binary_layout.addWidget(btn_browse)
        binary_group.setLayout(binary_layout)
        layout.addWidget(binary_group)
        
        client_group = QGroupBox("Configuration Client")
        client_layout = QVBoxLayout()
        
        self.public_client_rb = QRadioButton("Client Public")
        self.public_client_rb.setChecked(config['client_type'] == 'public')
        self.public_client_rb.toggled.connect(self._on_client_type_changed)
        client_layout.addWidget(self.public_client_rb)
        
        public_server_layout = QHBoxLayout()
        public_server_layout.addWidget(QLabel("Serveur:"))
        self.public_server_input = QLineEdit(config['public_server'])
        public_server_layout.addWidget(self.public_server_input)
        client_layout.addLayout(public_server_layout)
        
        self.private_client_rb = QRadioButton("Client Priv√©")
        # initialiser l'√©tat et connecter au m√™me handler
        self.private_client_rb.setChecked(config['client_type'] == 'private')
        self.private_client_rb.toggled.connect(self._on_client_type_changed)
        client_layout.addWidget(self.private_client_rb)
        
        private_port_layout = QHBoxLayout()
        private_port_layout.addWidget(QLabel("Port:"))
        self.private_port_input = QLineEdit(config['private_port'])
        self.private_port_input.setEnabled(False)
        private_port_layout.addWidget(self.private_port_input)
        client_layout.addLayout(private_port_layout)
        
        client_group.setLayout(client_layout)
        layout.addWidget(client_group)
        
        btn_save = QPushButton("üíæ Sauvegarder les param√®tres")
        btn_save.clicked.connect(self._save_params)
        layout.addWidget(btn_save)
        
        layout.addStretch()
        widget.setLayout(layout)
        # s'assurer que les contr√¥les sont dans l'√©tat correct au d√©part
        self._on_client_type_changed()
        return widget
    
    def _build_base_command(self) -> list:
        """Construit la base de toutes les commandes - SANS --wallet"""
        cmd = [config['wallet_binary']]
        
        if config['client_type'] == 'public':
            cmd.extend(['--client', 'public'])
            if config['public_server'] and config['public_server'] != 'https://nockchain-api.zorp.io':
                cmd.extend(['--public-grpc-server-addr', config['public_server']])
        else:
            cmd.extend(['--client', 'private'])
            if config['private_port'] and config['private_port'] != '50051':
                cmd.extend(['--private-grpc-server-port', config['private_port']])
        
        return cmd
    
    def _check_binary(self):
        """V√©rifie que le binaire est accessible"""
        try:
            result = subprocess.run(
                [config['wallet_binary'], '--help'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                self.log_area.append_log(f"‚úì Binaire trouv√©: {config['wallet_binary']}", "success")
            else:
                self.log_area.append_log(f"‚ö† Binaire non fonctionnel", "warning")
        except FileNotFoundError:
            self.log_area.append_log(f"‚úó Binaire non trouv√©: {config['wallet_binary']}", "error")
            QMessageBox.warning(
                self,
                "Binaire manquant",
                f"Le binaire '{config['wallet_binary']}' est introuvable.\n"
                "Veuillez le configurer dans l'onglet Param√®tres."
            )
        except Exception as e:
            self.log_area.append_log(f"‚úó Erreur: {str(e)}", "error")
    
    def _import_wallet(self):
        """Importe un wallet depuis un fichier .export ou .jam"""
        source_file, _ = QFileDialog.getOpenFileName(
            self,
            "S√©lectionner le fichier √† importer",
            str(Path.home() / "Desktop"),
            "Wallet Files (*.export *.jam *.dat);;All Files (*)"
        )
        
        if not source_file:
            return
        
        try:
            self.log_area.append_log(f"üì• Import depuis: {Path(source_file).name}", "info")
            
            cmd = self._build_base_command()
            cmd.append('import-keys')
            cmd.extend(['--file', source_file])
            
            self.log_area.append_log(f"$ {' '.join(cmd)}", "command")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                success_msg = self.parser.extract_success_message(result.stdout)
                
                if success_msg:
                    self.log_area.append_log(success_msg, "success")
                else:
                    self.log_area.append_log("‚úì Import r√©ussi", "success")
                
                # Le binaire g√®re tout en interne, marquer simplement comme import√©
                config['wallet_imported'] = True
                self.wallet_path_label.setText("‚úÖ Wallet import√©")
                self.wallet_path_label.setStyleSheet("color: #4CAF50;")
                self.statusBar().showMessage("Wallet: Import√© avec succ√®s")
                self.log_area.append_log("‚úì Wallet marqu√© comme import√©", "success")
                
                # R√©initialiser le moteur de transaction
                self._init_transaction_engine()
                
                self._refresh_balance()
                self._load_notes()
                
                QMessageBox.information(self, "Succ√®s", "Wallet import√© avec succ√®s!")
            else:
                error = self.parser.extract_error(result.stderr)
                self.log_area.append_log(f"‚úó Erreur: {error}", "error")
                QMessageBox.critical(self, "Erreur", f"√âchec de l'import:\n\n{error}")
        except Exception as e:
            self.log_area.append_log(f"‚úó Erreur: {str(e)}", "error")
            logger.error(f"Erreur import wallet: {e}")
    
    def _export_wallet(self):
        """Exporte le wallet"""
        if not config['wallet_imported']:
            QMessageBox.warning(self, "Attention", "Aucun wallet import√©")
            return
        
        dest_file, _ = QFileDialog.getSaveFileName(
            self,
            "Exporter le wallet",
            str(Path.home() / "Desktop" / "wallet_export.dat"),
            "DAT Files (*.dat);;All Files (*)"
        )
        
        if not dest_file:
            return
        
        try:
            self.log_area.append_log(f"üì§ Export vers: {Path(dest_file).name}", "info")
            
            cmd = self._build_base_command()
            cmd.append('export-keys')
            cmd.extend(['--out', dest_file])
            
            self.log_area.append_log(f"$ {' '.join(cmd)}", "command")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                self.log_area.append_log("‚úì Export r√©ussi", "success")
                QMessageBox.information(self, "Succ√®s", f"Wallet export√© vers:\n{dest_file}")
            else:
                error = self.parser.extract_error(result.stderr)
                self.log_area.append_log(f"‚úó Erreur: {error}", "error")
                QMessageBox.critical(self, "Erreur", f"√âchec de l'export:\n\n{error}")
        except Exception as e:
            self.log_area.append_log(f"‚úó Erreur: {str(e)}", "error")
            logger.error(f"Erreur export wallet: {e}")
    
    def _refresh_balance(self):
        """Rafra√Æchit le solde"""
        if not config['wallet_imported']:
            QMessageBox.warning(self, "Attention", "Veuillez importer un wallet d'abord")
            return
        
        try:
            cmd = self._build_base_command()
            cmd.append('show-balance')
            
            self.log_area.append_log(f"$ {' '.join(cmd)}", "command")
            self.log_area.append_log("‚è≥ R√©cup√©ration du solde...", "info")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                output = result.stdout
                balance = self.parser.extract_balance(output)
                metadata = self.parser.extract_metadata(output)
                
                if balance is not None:
                    self.balance_label.setText(f"{balance:,.2f} nicks")
                    self.log_area.append_log(f"üí∞ Solde: {balance:,.2f} nicks", "success")
                    
                    num_notes = metadata.get('num_notes')
                    wallet_version = metadata.get('wallet_version')
                    height = metadata.get('height')
                    block_hash = metadata.get('block_hash')
                    
                    if num_notes is not None:
                        self.log_area.append_log(f"üìù Nombre de notes: {num_notes}", "info")
                    
                    if wallet_version:
                        self.log_area.append_log(f"üì¶ Version wallet: {wallet_version}", "info")
                    
                    if height:
                        self.log_area.append_log(f"üìä Hauteur: {height:,}", "info")
                    
                    if block_hash:
                        short_hash = f"{block_hash[:8]}...{block_hash[-8:]}"
                        self.log_area.append_log(f"üîó Bloc: {short_hash}", "info")
                    
                    success_msg = self.parser.extract_success_message(output)
                    if success_msg:
                        self.log_area.append_log(success_msg, "success")
                else:
                    self.log_area.append_log("‚ö† Impossible de parser le solde", "warning")
                    clean = self.parser.clean_output(output)
                    self.log_area.append_log(clean, "info")
            else:
                error = self.parser.extract_error(result.stderr)
                self.log_area.append_log(f"‚úó Erreur: {error}", "error")
                
        except subprocess.TimeoutExpired:
            self.log_area.append_log("‚úó Timeout lors de la r√©cup√©ration du solde", "error")
        except Exception as e:
            self.log_area.append_log(f"‚úó Erreur: {str(e)}", "error")
            logger.error(f"Erreur refresh balance: {e}")
    
    def _load_notes(self):
        """Charge la liste des notes"""
        if not config['wallet_imported']:
            QMessageBox.warning(self, "Attention", "Veuillez importer un wallet d'abord")
            return
        
        try:
            cmd = self._build_base_command()
            cmd.append('list-notes')
            
            self.log_area.append_log(f"$ {' '.join(cmd)}", "command")
            self.log_area.append_log("‚è≥ Chargement des notes...", "info")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                notes = self.parser.parse_notes_list(result.stdout)
                
                # Mettre √† jour les deux tables
                for table in [self.notes_table, self.notes_display]:
                    table.setRowCount(0)
                    
                    for note in notes:
                        row = table.rowCount()
                        table.insertRow(row)
                        
                        if table == self.notes_table:
                            checkbox = QCheckBox()
                            table.setCellWidget(row, 0, checkbox)
                            table.setItem(row, 1, QTableWidgetItem(note['name']))
                            table.setItem(row, 2, QTableWidgetItem(f"{note['amount']:.2f}"))
                            table.setItem(row, 3, QTableWidgetItem(note['unit']))
                        else:
                            table.setItem(row, 0, QTableWidgetItem(note['name']))
                            table.setItem(row, 1, QTableWidgetItem(f"{note['amount']:.2f}"))
                            table.setItem(row, 2, QTableWidgetItem(note['unit']))
                
                self.log_area.append_log(f"‚úì {len(notes)} note(s) charg√©e(s)", "success")
            else:
                error = self.parser.extract_error(result.stderr)
                self.log_area.append_log(f"‚úó Erreur: {error}", "error")
                
        except subprocess.TimeoutExpired:
            self.log_area.append_log("‚úó Timeout lors du chargement des notes", "error")
        except Exception as e:
            self.log_area.append_log(f"‚úó Erreur: {str(e)}", "error")
            logger.error(f"Erreur load notes: {e}")
    
    def _show_address(self):
        """Affiche l'adresse du wallet"""
        if not config['wallet_imported']:
            QMessageBox.warning(self, "Attention", "Veuillez importer un wallet d'abord")
            return
        
        try:
            cmd = self._build_base_command()
            cmd.append('list-master-addresses')
            
            self.log_area.append_log(f"$ {' '.join(cmd)}", "command")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                address = self.parser.extract_address(result.stdout)
                if address:
                    self.receive_address.setText(address)
                    self.log_area.append_log(f"‚úì Adresse: {address}", "success")
                else:
                    clean = self.parser.clean_output(result.stdout)
                    self.log_area.append_log(clean, "info")
            else:
                error = self.parser.extract_error(result.stderr)
                self.log_area.append_log(f"‚úó Erreur: {error}", "error")
                
        except Exception as e:
            self.log_area.append_log(f"‚úó Erreur: {str(e)}", "error")
            logger.error(f"Erreur show address: {e}")
    
    def _copy_address(self):
        """Copie l'adresse dans le presse-papier"""
        address = self.receive_address.text()
        if address and address != "Cliquez sur 'Afficher l'adresse' pour voir votre PKH":
            QApplication.clipboard().setText(address)
            self.log_area.append_log("‚úì Adresse copi√©e", "success")
            self.statusBar().showMessage("Adresse copi√©e!", 3000)
        else:
            QMessageBox.warning(self, "Attention", "Aucune adresse √† copier")
    
    def _add_recipient(self):
        """Ajoute un destinataire √† la liste"""
        address = self.recipient_address.text().strip()
        amount = self.recipient_amount.value()
        
        if not address:
            QMessageBox.warning(self, "Attention", "Veuillez entrer une adresse")
            return
        
        if amount <= 0:
            QMessageBox.warning(self, "Attention", "Le montant doit √™tre sup√©rieur √† 0")
            return
        
        self.recipients.append({
            'address': address,
            'amount': amount
        })
        
        self._update_recipients_display()
        self.recipient_address.clear()
        self.recipient_amount.setValue(0)
        
        self.log_area.append_log(f"‚úì Destinataire ajout√©: {address} ({amount} nicks)", "success")
    
    def _clear_recipients(self):
        """Efface tous les destinataires"""
        self.recipients.clear()
        self._update_recipients_display()
        self.log_area.append_log("‚úì Liste des destinataires effac√©e", "info")
    
    def _update_recipients_display(self):
        """Met √† jour l'affichage des destinataires"""
        if not self.recipients:
            self.recipients_list.setPlainText("Aucun destinataire")
            return
        
        text = ""
        for i, r in enumerate(self.recipients, 1):
            text += f"{i}. {r['address'][:20]}... ‚Üí {r['amount']} nicks\n"
        
        self.recipients_list.setPlainText(text)
    
    def _get_selected_notes(self) -> List[str]:
        """R√©cup√®re les notes s√©lectionn√©es"""
        selected_notes = []
        for row in range(self.notes_table.rowCount()):
            checkbox = self.notes_table.cellWidget(row, 0)
            if checkbox and checkbox.isChecked():
                name_item = self.notes_table.item(row, 1)
                if name_item:
                    selected_notes.append(name_item.text())
        return selected_notes
    
    def _calculate_fee(self) -> int:
        """Calcule les frais"""
        if self.custom_fee_check.isChecked():
            return self.custom_fee_input.value()
        
        priority = self.fee_priority.currentText().lower()
        base_fee = 10
        num_inputs = sum(1 for r in range(self.notes_table.rowCount()) 
                         if self.notes_table.cellWidget(r, 0) and 
                         self.notes_table.cellWidget(r, 0).isChecked())
        num_outputs = len(self.recipients)
        
        multipliers = {'low': 1, 'medium': 2, 'high': 3, 'urgent': 5}
        multiplier = multipliers.get(priority, 1)
        
        return base_fee * (1 + num_inputs + num_outputs) * multiplier
    
    def _create_transaction(self):
        """Cr√©e et envoie une transaction"""
        if not config['wallet_imported']:
            QMessageBox.warning(self, "Attention", "Veuillez importer un wallet d'abord")
            return
        
        if not self.recipients:
            QMessageBox.warning(self, "Attention", "Ajoutez au moins un destinataire")
            return
        
        for recipient in self.recipients:
            if recipient['amount'] <= 0:
                QMessageBox.warning(self, "Attention", f"Montant invalide pour {recipient['address']}")
                return
        
        # Mettre √† jour le moteur
        if self.tx_engine:
            self.tx_engine.wallet_path = config['wallet_path']
            self.tx_engine.client_type = config['client_type']
            self.tx_engine.public_server = config['public_server']
        else:
            self._init_transaction_engine()
        
        try:
            self.log_area.append_log("üîÑ Pr√©paration de la transaction...", "info")
            
            recipients_list = [(r['address'], r['amount']) for r in self.recipients]
            note_names = self._get_selected_notes()
            
            if not note_names:
                QMessageBox.warning(self, "Attention", "S√©lectionnez au moins une note")
                return
            
            fee = self._calculate_fee()
            total_amount = sum(r[1] for r in recipients_list) + fee
            
            self.log_area.append_log(f"üìù Destinataires: {len(recipients_list)}", "info")
            self.log_area.append_log(f"üí≥ Notes utilis√©es: {len(note_names)}", "info")
            self.log_area.append_log(f"üí∞ Montant total: {total_amount} nicks (dont {fee} de frais)", "info")
            
            # Demander confirmation
            confirm_msg = f"Confirmer la transaction ?\n\n"
            confirm_msg += f"Destinataires: {len(recipients_list)}\n"
            confirm_msg += f"Montant total: {total_amount} nicks\n"
            confirm_msg += f"Frais: {fee} nicks\n\n"
            confirm_msg += "Cette action est irr√©versible."
            
            reply = QMessageBox.question(
                self,
                "Confirmation",
                confirm_msg,
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                self.log_area.append_log("‚ùå Transaction annul√©e", "warning")
                return
            
            self.log_area.append_log("üöÄ Cr√©ation et envoi de la transaction...", "info")
            
            # Cr√©er et envoyer la transaction
            result = self.tx_engine.create_and_send_transaction(
                recipients=recipients_list,
                note_names=note_names,
                fee=fee
            )
            
            if result.success:
                self.log_area.append_log("‚úì Transaction cr√©√©e et envoy√©e avec succ√®s!", "success")
                
                if result.tx_id:
                    self.log_area.append_log(f"üÜî ID: {result.tx_id}", "success")
                    self.statusBar().showMessage(f"Transaction envoy√©e: {result.tx_id[:16]}...", 5000)
                
                if result.message:
                    self.log_area.append_log(f"‚ÑπÔ∏è {result.message}", "info")
                
                # Afficher un message de succ√®s
                msg = "Transaction envoy√©e avec succ√®s!\n\n"
                if result.tx_id:
                    msg += f"ID: {result.tx_id[:32]}...\n\n"
                msg += "La transaction sera confirm√©e dans les prochains blocs."
                
                QMessageBox.information(self, "Succ√®s", msg)
                
                # Effacer les destinataires et rafra√Æchir
                self._clear_recipients()
                
                # Attendre un peu puis rafra√Æchir
                QTimer.singleShot(2000, self._refresh_balance)
                QTimer.singleShot(2000, self._load_notes)
                
            else:
                error_msg = result.error or result.message or "Erreur inconnue"
                self.log_area.append_log(f"‚úó √âchec: {error_msg}", "error")
                
                if result.raw_output:
                    self.log_area.append_log("--- D√©tails ---", "info")
                    for line in result.raw_output.split('\n'):
                        if line.strip():
                            self.log_area.append_log(line, "info")
                
                QMessageBox.critical(self, "Erreur", f"√âchec:\n\n{error_msg}")
        
        except Exception as e:
            error_msg = str(e)
            self.log_area.append_log(f"‚úó Erreur: {error_msg}", "error")
            QMessageBox.critical(self, "Erreur", f"Erreur:\n\n{error_msg}")
            logger.error(f"Erreur transaction: {e}", exc_info=True)
    
    def _on_client_type_changed(self):
        """G√®re le changement de type de client"""
        if self.public_client_rb.isChecked():
            self.public_server_input.setEnabled(True)
            self.private_port_input.setEnabled(False)
        else:
            self.public_server_input.setEnabled(False)
            self.private_port_input.setEnabled(True)
    
    def _browse_binary(self):
        """Parcourir pour s√©lectionner le binaire"""
        binary_file, _ = QFileDialog.getOpenFileName(
            self,
            "S√©lectionner le binaire nockchain-wallet",
            str(Path.home()),
            "All Files (*)"
        )
        
        if binary_file:
            self.binary_path_input.setText(binary_file)
    
    def _save_params(self):
        """Sauvegarde les param√®tres"""
        config['wallet_binary'] = self.binary_path_input.text()
        config['client_type'] = 'public' if self.public_client_rb.isChecked() else 'private'
        config['public_server'] = self.public_server_input.text()
        config['private_port'] = self.private_port_input.text()
        
        # R√©initialiser le moteur de transaction
        self._init_transaction_engine()
        
        self.log_area.append_log("‚úì Param√®tres sauvegard√©s", "success")
        QMessageBox.information(self, "Succ√®s", "Param√®tres sauvegard√©s")
        self._check_binary()


def main():
    """Point d'entr√©e de l'application"""
    app = QApplication(sys.argv)
    
    app.setStyle("Fusion")
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Base, QColor(25, 25, 25))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Text, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 0, 0))
    palette.setColor(QPalette.ColorRole.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(0, 0, 0))
    app.setPalette(palette)
    
    window = NockchainWalletGUI()
    window.show()
    
    sys.exit(app.exec())


if __name__ == '__main__':
    main()
